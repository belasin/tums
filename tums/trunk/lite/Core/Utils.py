""" A utilities library """
import os, socket, fcntl, struct, array, smtplib, time, sys, traceback
from email.MIMEMultipart import MIMEMultipart
from email.MIMEBase import MIMEBase
from email.MIMEText import MIMEText
from email.Utils import COMMASPACE, formatdate
from email import Encoders
from Core import confparse
   
class SetDefaults:
    BaseDir = '/usr/local/tcs/tums'

try:
    import Settings
except:
    Settings = SetDefaults()

months = {
    1: 'January',
    2: 'February', 
    3: 'March',
    4: 'April',
    5: 'May',
    6: 'June',
    7: 'July',
    8: 'August',
    9: 'September',
    10: 'October',
    11: 'November',
    12: 'December',
}

portCache = {}

def currentProfile():
    try:
        l = open('/usr/local/tcs/tums/currentProfile')
    except:
        return ("Default", "default.py")
    i = l.read().replace('\n', '').strip() 
    name = i[:-3].replace('_', ' ').capitalize()
    return (name, i)

def runningProfile():
    try:
        l = open('/usr/local/tcs/tums/runningProfile')
    except:
        return ("Default", "default.py")
    i = l.read().replace('\n', '').strip() 
    name = i[:-3].replace('_', ' ').capitalize()
    return (name, i)

def lookupIp(ip):
    # Try look in the leases config first
    conf =  __import__('config')
    leases = conf.DHCP.get('leases', {})
    for lip, hostmac in conf.DHCP.get('leases', {}).items():
        host, mac = hostmac
        if lip == ip:
            return host

    from twisted.names import client
    def res(lookup):
        name = str(lookup[0][0].payload.name)
        # Take away our common domain and strip any residual dots
        return name.replace(Settings.defaultDomain, '').strip('.')

    def failure(eek):
        return ip

    def ipToPtr(ip):
        return "%s.in-addr.arpa" % '.'.join([i for i in reversed(ip.split('.'))])

    return client.lookupAddress(ipToPtr(ip)).addCallbacks(res, failure)

def getMAC(ip):
    lf = open('/proc/net/arp')
    for i in lf:
        if ip in i:
            return i.split()[3].lower()

    # Try look in the leases config
    conf =  __import__('config')
    leases = conf.DHCP.get('leases', {})
    mac = conf.DHCP.get('leases', {}).get(ip, None)
    if mac:
        return mac[1]

    return None # Didn't find one

def getIpFromMac(mac):
    lf = open('/proc/net/arp')
    for i in lf:
        if mac.lower() in i.lower():
            return i.split()[0]

    conf =  __import__('config')
    leases = conf.DHCP.get('leases', {})
    for ip, hostmac in conf.DHCP.get('leases', {}).items():
        host, lmac = hostmac
        if lmac == mac:
            return ip

    return None # Didn't find one

def resolvePort(port):
    """Get the canonical ARIN name for a port"""
    if not portCache: 
        print "Building port cache"
        ports = open('/etc/services', 'r')
        for ln in ports:
            l = ln.strip()
            if l and l[0] != "#":
                defn = l.split()
                portCache[int(defn[1].split('/')[0])] = defn[0]
        portCache[9680] = 'Thusa Thebe'
        portCache[9682] = 'Thusa TUMS'
        portCache[9682] = 'Thusa NetFlow Concentrator'
        portCache[65535] = 'Unknown Services*'
        print "Done!"
    
    return portCache.get(port, str(port))


def exceptionOccured(e):
    text = traceback.format_exc()
    print text
    sendMail("%s <tums@thusa.net>" % Settings.LDAPOrganisation, ["colin@thusa.co.za"], "TUMS Error", text)
    #raise e

def intToH(bytes):
    prefix = ['GB', 'MB', 'KB', 'B']
    val = bytes
    while val > 1000:
        val = val/1000.0
        prefix.pop()
    return "%0.2f%s" % (val, prefix[-1])


def reconfigure(plug):
    """Call a reconfigure action for a plugin """
    os.system(Settings.BaseDir+'/configurator --%s' % plug)

def writeConf(conf, data, comsymbol):
    """ Writes a config file - not very usefull but modularises stuff"""
    if data:
        l = open(conf, 'wt')
        if comsymbol:
            l.write(comsymbol + '# Generated by TCS Configurator on %s \n' % time.ctime())
        l.write(data)
        l.close()

def sendMail(send_from, send_to, subject, text, files=[], server="localhost", html=False):
    """Sends an email"""
    assert type(send_to)==list
    assert type(files)==list

    msg = MIMEMultipart()
    msg['From'] = send_from
    msg['To'] = COMMASPACE.join(send_to)
    msg['Date'] = formatdate(localtime=True)
    msg['Subject'] = subject

    if html:
        msg.attach(MIMEText(text, 'html'))
    else:
        msg.attach(MIMEText(text))

    for f in files:
        part = MIMEBase('application', "octet-stream")
        part.set_payload( open(f,"rb").read() )
        Encoders.encode_base64(part)
        part.add_header('Content-Disposition', 'attachment; filename="%s"' % os.path.basename(f))
        msg.attach(part)
    from twisted.mail import smtp

    def finished(_):
        print "Mail sent", _
        return True
    # Clean realFrom
    if "<" in send_from:
        realFrom = send_from.split('<')[-1].split('>')[0]
    else:
        realFrom = send_from
    return smtp.sendmail('localhost', realFrom, [send_to], msg.as_string()).addCallbacks(finished, finished)


def getInterfaces():
    """ Returns machine interfaces """
    max_possible = 128  # arbitrary. raise if needed.
    bytes = max_possible * 32
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    names = array.array('B', '\0' * bytes)
    outbytes = struct.unpack('iL', fcntl.ioctl(
        s.fileno(),
        0x8912,  # SIOCGIFCONF
        struct.pack('iL', bytes, names.buffer_info()[0])
    ))[0]
    namestr = names.tostring()
    ilist = [namestr[i:i+32].split('\0', 1)[0] for i in range(0, outbytes, 32)]
    nlist = []
    for i in ilist:
        if i not in nlist:
            nlist.append(i)
    return nlist

def yesno(bool):
    """Returns C(str) 'yes' for bool value of True and 'no' for False"""
    return (bool and "yes") or "no"

def parseNet():
    """ Returns our configurator network information """
    conf = confparse.Config()
    return conf.EthernetDevices

def buildNet(net):
    """ Builds a network configuration """
    out = ""
    for key in net.keys():
        if type(net[key]) is list:
            out += "%s=(\n" % (key,)

            for l in net[key]:
                out += '    "%s"\n' % (l,)

            out += ")\n\n"
        else:
            out += '%s="%s"\n\n' % (key, net[key])

    return out

def getNetwork(ip):
    """ Returns the network address and CIDR for a given CIDR IP"""
    wmask = '.'.join(ip.split('/')[0].split('.')[:3])
    sadr = ip.split('.')[-1].split('/')[0]
    mask = ip.split('/')[-1]
    naddr = int(sadr) & ~((1 << (32 - int(mask))) - 1)
    return '%s.%s/%s' % (wmask, naddr, mask)

def getV6Network(ip):
    # XXX This method really sucks, only works in 16 bit increments
    prefix = ip.split('/')[-1]
    mip = ip.split('/')[0]
    ipseg1 = mip.split('::')[0]
    ipseg2 = mip.split('::')[1]
    ip = [0,0,0,0,0,0,0,0]
    for i,j in enumerate(ipseg1.split(':')):
        ip[i] = int(j, 16)
    if ipseg2:
        for i,j in enumerate(reversed(ipseg2.split(':'))):
            ip[7-i] = int(j, 16)
    segs = int(prefix)/16
    fix =  ':'.join([str(hex(i)) for i in ip[:segs]]) + '::/' + prefix
    return fix.replace('0x', '')

def cidr2netmask(cidr):
    return socket.inet_ntoa(struct.pack('<L', socket.htonl(0xffffffff - ((1 << (32-int(cidr))) -1 ))))

def netmask2cidr(netmask):
    netmaskbytes = socket.inet_aton(netmask)
    mylong = struct.unpack(">L", netmaskbytes)[0]
    tail = mylong ^ 0xffffffff
    c = 32
    while tail > 0:
        tail = tail >> 1
        c -= 1
    return c

def startTwisted(application, startDir = './', nodaemon = 0, logfile=None, rundir='.', appname='tums', pidfile='/var/run/tums.pid'):
    """ A freezable twistd bootstrap layer """
    from twisted.application import service, internet, strports, app
    from twisted.python import log, syslog
    try:
        from twisted.scripts import _twistd_unix as twistd
    except:
        from twisted.scripts import twistd
    config = {
        'profile': None,          'reactor': None,
        'encrypted': 0,           'syslog': 0,
        'prefix': appname,      'report-profile': None,
        'euid': 0,                'file': 'twistd.tap',
        'originalname': appname,  'rundir': rundir,
        'logfile': logfile,       'nodaemon': nodaemon,
        'uid': None,              'xml': None,
        'chroot': None,           'no_save': True,
        'quiet': 0,               'source': None,
        'nothotshot': 0,          'gid': None,
        'savestats': 0,           'debug': False,
        'pidfile': pidfile
    }

    twistd.checkPID(config['pidfile'])
    #app.installReactor(config['reactor'])

    config['nodaemon'] = config['nodaemon'] or config['debug']

    oldstdout = sys.stdout
    oldstderr = sys.stderr

    twistd.startLogging(config['logfile'], config['syslog'], 
        config['prefix'], config['nodaemon'])

    app.initialLog()

    twistd.startApplication(config, application)

    app.runReactorWithLogging(config, oldstdout, oldstderr)
    twistd.removePID(config['pidfile'])
    app.reportProfile(config['report-profile'],
    service.IProcess(application).processName)
    log.msg("Server Shut Down.")

