import config, os
from Core import Utils
import socket, struct

class Plugin(object):
    parameterHook = "--debnet"
    parameterDescription = "Reconfigure Debian network"
    parameterArgs = ""
    autoRun = True
    required = "debian"
    depends = ['fprobe']
    configFiles = [ 
        "/etc/network/interfaces",
    ]

    def reloadServices(self):
        os.system('/etc/init.d/networking restart')

        # Restart all the PPP's
        os.system('killall -9 pppd')
        for i in os.listdir('/etc/ppp/peers'):
            if 'wan' in i:
                os.system('pon %s' % i)
            

    def cidr2netmask(self, cidr):
        return socket.inet_ntoa(struct.pack('<L', socket.htonl(0xffffffff - ((1 << (32-cidr)) -1 ))))

    def PPPoEBuilder(self, unit, device, username, password, default=False):
        """
        @param unit: PPP unit number
        @param device: Ethernet PAC bridge device
        @param username: Username for PPPoE connection
        @param password: Password for PPPoE connection
        @param default: Use this as default route
        """
        peerConfig = """noipdefault
hide-password
lcp-echo-interval 30
lcp-echo-failure 4
noauth
persist
mtu 1492
persist
maxfail 0
holdoff 20
plugin rp-pppoe.so %s
user "%s"
unit %s\n""" % (device, username, unit)
        if default:
            peerConfig += "defaultroute\nreplacedefaultroute\n"

        l = open('/etc/ppp/peers/wan%s' % unit, 'wt')
        l.write(peerConfig)
        l.close()

        pap = open('/etc/ppp/pap-secrets', 'a+')
        chap = open('/etc/ppp/chap-secrets', 'a+')
        passLine = '"%s"   *   "%s"\n' % (username, password)
        if not passLine in pap.readlines():
            pap.write(passLine)
            chap.write(passLine)
        pap.close()
        chap.close()

        return "auto wan%s\niface wan%s inet ppp\nprovider wan%s\n  pre-up /sbin/ifconfig %s up\n" % (unit, unit, unit, device)

    def vlanBuilder(self, i, defn):
        iface = {
            'ip': defn['ip'].split('/')[0],
            'vnum': i.replace('vlan',''),
            'network': defn['network'].split('/')[0],
            'netmask': Utils.cidr2netmask(defn['ip'].split('/')[-1]),
            'interface': defn['interface']
        }

        ifacedef = """auto vlan%(vnum)s
iface vlan%(vnum)s inet static
  address %(ip)s
  netmask %(netmask)s
  network %(network)s
  vlan_raw_device %(interface)s
""" % iface
        # check routes
        if defn.get('routes', None):
            for dest, gw in defn['routes']:
                if dest=='default':
                    ifacedef  += '  gateway %s\n' % gw
 
        try:
            if defn.get('aliases', None):
                for alias in defn['aliases']:
                    ifacedef += '  up   ip addr add %s dev vlan%s || true\n' % (alias, iface['vnum'])
                    ifacedef += '  down ip addr del %s dev vlan%s || true\n' % (alias, iface['vnum'])
        except:
            print "Failed to configure aliases for %s" % i

        ifacedef += "\n"
        return ifacedef

    def writeConfig(self, *a):
        # We must ALWAYS have a loopback defenition or else lots of things break quite horribly
        net = "# Generated by TUMS Configurator\nauto lo\niface lo inet loopback\n\n" 
        dhcpifaces = []

        pap = open('/etc/ppp/pap-secrets', 'wt')
        chap = open('/etc/ppp/chap-secrets', 'wt')
        pap.write("# Vulani PAP-Secrets\n\n")
        pap.write("*       hostname        ""      *\n\n")
        chap.write("# Vulani PAP-Secrets\n\n")
        chap.write("*       hostname        ""      *\n\n")
        pap.close()
        chap.close()

        for interface, defin in reversed(config.EthernetDevices.items()):
            if interface != "extra" and "vlan" not in interface:
                net += "auto %s\niface %s inet " % (interface, interface)
                
                if defin['type'].lower() == 'dhcp':
                    net += 'dhcp\n'
                elif defin['type'].lower() == 'manual':
                    net += 'manual\n'
                else:
                    ip, cidr = tuple(defin['ip'].split('/'))
                    net += 'static\n'
                    net += '  address %s\n' % ip
                    net += '  netmask %s\n' % self.cidr2netmask(int(cidr))
                    if defin.get('mtu'):
                        net += '  mtu %s\n' % defin['mtu'] 

                if interface[0:2] == "br" and "bridge_ports" in defin:
                    net += '  bridge_ports %s\n' % " ".join(defin['bridge_ports'])
                    net += '  bridge_stp off\n  bridge_fd 0\n  bridge_maxwait 0\n'

                # aliases (use ip ro on post-up conditions)
                if defin.get('aliases', None):
                    for alias in defin['aliases']:
                        net += '  up   ip addr add %s dev %s || true\n' % (alias, interface)
                        net += '  down ip addr del %s dev %s || true\n' % (alias, interface)

                if defin.get('ipv6', None):
                    net += '  up echo 1 > /proc/sys/net/ipv6/conf/all/forwarding || true\n'
                    net += '  up ip addr add %s dev %s || true\n' % (defin['ipv6'], interface)
                
                # check routes - add to Zebra (separate plugin) if not a default
                if defin.get('routes', None):
                    for dest, gw in defin['routes']:
                        if dest=='default':
                            net += '  gateway %s\n' % gw
                if defin.get('extra', None):
                    net += defin['extra'] + '\n'
                net += '\n'

            if "vlan" in interface:
                net += self.vlanBuilder(interface, defin)

            if defin.get('dhcpserver', False):
                dhcpifaces.append(interface)

        dhcpconf = """# On what interfaces should the DHCP server (dhcpd) serve DHCP requests?
#       Separate multiple interfaces with spaces, e.g. "eth0 eth1".
INTERFACES="%s"\n""" % (' '.join(dhcpifaces))

        d3serv = open('/etc/default/dhcp3-server', 'wt')
        d3serv.write(dhcpconf)
        d3serv.close()

        if config.EthernetDevices.get('extra', None):
            net += config.EthernetDevices['extra']
            net += '\n'
        
        if config.Tunnel.get('ipv6'):
            tcnf = config.Tunnel['ipv6']
            
            defn = """auto stf%(num)s
iface stf%(num)s inet6
    address %(localaddr)s
    netmask %(cidrn)s
    endpoint %(endpoint)s
    up ip -6 route add 2003::/3 dev stf%(num)s
"""

        # Clean up unconfigured wan scripts
        for wan in os.listdir('/etc/ppp/peers'):
            if 'wan' in wan:
                num = wan.replace('wan', '')
                if 'ppp'+num not in config.WANDevices.keys():
                    # Not in WANDevices...
                    os.system('rm /etc/ppp/peers/%s' % wan)

        # Create all new wan scripts
        for interface, defin in config.WANDevices.items():
            if interface != "extra":
                unit = interface.strip('ppp')
                default = False
                if 'defaultroute' in  defin['pppd']:
                    default = True
                net += self.PPPoEBuilder(unit, defin['link'], defin['username'], defin['password'], default)

        if config.WANDevices.get('extra', None):
            net += config.WANDevices['extra']
            net += '\n'

        netConf = open('/etc/network/interfaces', 'wt')
        netConf.write(net)
        netConf.close()


